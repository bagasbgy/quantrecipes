% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step_ma.R
\name{step_ma}
\alias{step_ma}
\alias{tidy.step_ma}
\title{Extract moving average features}
\usage{
step_ma(recipe, ..., ma_fun = TTR::SMA, n = 10, weights = NULL,
  ma_options = list(), state = FALSE, ratio = TRUE, prefix = "ma",
  prices = NULL, role = "predictor", trained = FALSE, skip = FALSE,
  id = rand_id("ma"))

\method{tidy}{step_ma}(x, info = "terms", ...)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the
sequence of operations for this recipe.}

\item{...}{One or more selector functions to choose which
variables are affected by the step. See
\link[recipes:selections]{selections (from recipes package)} for more details.}

\item{ma_fun}{A \code{function} to extract moving average, or a \code{character}
vector of length one which specify a moving average function.
Defaults to \link[TTR:SMA]{TTR::SMA}.}

\item{n}{A \code{numeric} vector of length one which specify
the moving average window.}

\item{weights}{A \code{character} vector of length one that specify a column name,
or a \code{numeric} vector for \code{ma_fun} that has \code{wts} or \code{volume} argument.
See details for more information.}

\item{ma_options}{A \code{list} of additional argument(s) that would be passed
to \code{ma_fun} function.}

\item{state}{An option to specify whether to return
the current states of the calculated moving averages. See details for
more informations. Defaults to \code{TRUE}.}

\item{ratio}{Whether to return the moving average \code{spread} as ratio or
absolute difference. See details for more informations. Defaults to \code{TRUE}.}

\item{prefix}{A \code{character} vector of length one that would be used
as a prefix to the created moving average columns. Defaults to \code{"ma"}.}

\item{prices}{A container for asd. Leave to \code{NULL}
as it will be populated by \link[recipes:prep.recipe]{prep()} function.}

\item{role}{For model terms created by this step, what analysis
role should they be assigned? By default, the function assumes
that the created moving average columns will be used
as \code{"predictors"} in a model.}

\item{trained}{A logical to indicate if the necessary informations for
preprocessing have been estimated.}

\item{skip}{A logical. Should the step be skipped when the
recipe is baked by \link[recipes:bake.recipe]{bake()}? While all operations are baked
when \link[recipes:prep.recipe]{prep()} is run, some operations may not
be able to be conducted on new data (e.g. processing
the outcome variable(s)). Care should be taken when using \code{skip = TRUE}
as it may affect the computations for subsequent operations}

\item{id}{A character string that is unique to this step to identify it.}

\item{x}{A \code{step_ma} object.}

\item{info}{Options for \code{tidy()} method; whether to return tidied
information for used \code{"terms"} or \code{"params"}}
}
\value{
An updated version of \code{recipe} with the new step
added to the sequence of existing steps (if any).
}
\description{
\code{step_ma} creates a \strong{specification} of a recipe
step that will extract \strong{moving average} features
from an asset price historical data.
}
\details{
The output from this step are several new columns
which contains the extracted moving average features.

For basic output, this step will produces:
\itemize{
\item \code{value}: the moving average value
}

If \code{state} argument is \code{TRUE}, it will also produces:
\itemize{
\item \code{spread}: current spread to the \code{prices} variable
\item \code{state}: current state of the spread; \code{"bullish"} or \code{"bearish"}
}

Note that if \code{ratio} argument is \code{TRUE}, the \code{spread} value would be
returned as a ratio to \code{prices} variable instead of an absolute difference.
}
\examples{

# import libs
library(quantrecipes)

# basic usage
rec <- recipe(. ~ ., data = btcusdt) \%>\%
  step_ma(close) \%>\%
  step_naomit(all_predictors()) \%>\%
  prep()

# get preprocessed data
juice(rec)

# using state argument
rec <- recipe(. ~ ., data = btcusdt) \%>\%
  step_ma(close, state = TRUE) \%>\%
  step_naomit(all_predictors()) \%>\%
  prep()

# get preprocessed data
juice(rec)

# using pass-through options
rec <- recipe(. ~ ., data = btcusdt) \%>\%
  step_ma(close,
    ma_fun = TTR::EMA,
    n = 10,
    ma_options = list(wilder = TRUE),
    state = TRUE
  ) \%>\%
  step_naomit(all_predictors()) \%>\%
  prep()

# get preprocessed data
juice(rec)

# using custom weights for weighted moving average
rec <- recipe(. ~ ., data = btcusdt) \%>\%
  step_ma(close,
    ma_fun = TTR::WMA,
    n = 10,
    weights = c(rep(1, 9), 10),
    state = TRUE
  ) \%>\%
  step_naomit(all_predictors()) \%>\%
  prep()

# get preprocessed data
juice(rec)

# using volume-based moving average
rec <- recipe(. ~ ., data = btcusdt) \%>\%
  step_ma(close,
    ma_fun = TTR::VWMA,
    n = 10,
    weights = "volume",
    state = TRUE
  ) \%>\%
  step_naomit(all_predictors()) \%>\%
  prep()

# get preprocessed data
juice(rec)

}
